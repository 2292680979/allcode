1. 操作系统重点  https://juejin.im/entry/592257b62f301e006b183b95#comment![img](https://user-gold-cdn.xitu.io/2017/5/22/9ec446cf01928b9a62f9d852690476bd?imageslim)

2. 操作系统的四个特性：并发：同一段时间内多个程序执行(注意区别并行和并发，前者是同一时刻的多个事件，后者是同一时间段内的多个事件)
   共享：系统中的资源可以被内存中多个并发执行的进线程共同使用
   虚拟：通过时分复用（如分时系统）以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个
   异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进    函数中同步异步：同步就是一直要执行到返回最终结果。异步就是直接返回，但是返回的不是最终结果，调用者不能通过这种调用得到结果，以后可以通过被调用者提供的某种方式(被调用者通知调用者、调用者反复查询、回调)，来取回最终结果。   进程异步：内存中的每个进程何时执行,何时暂停,以怎样的速度向前推进,每道程序总共需要多少时间才能完成等,都是不可预知的。由于资源等因素的限制，进程的执行通常都不是“一气呵成”，而是以“停停走走”的方式运行。
   
3. 操作系统的主要功能：处理机管理：处理机分配都是以进程为单位，所以处理机管理也被看做是进程管理。包括进程控制，进程同步，进程通信和进程调度
   存储器管理（或者内存管理）：内存分配，内存保护，地址映射，内存扩充
   设备管理：管理所有外围设备，包括完成用户的IO请求；为用户进程分配IO设备；提高IO设备利用率；提高IO速度；方便IO的使用
   文件管理：管理用户文件和系统文件，方便使用同时保证安全性。包括：磁盘存储空间管理，目录管理，文件读写管理以及文件共享和保护
   提供用户接口：程序接口（如API）和用户接口（如GUI）
   
4. 进程状态转换：运行，就绪，阻塞。![image-20200721095505742](D:\源码\笔记\图片\image-20200721095505742.png)

5. 进程与线程区别（基本单位，切换时的资源，通信）：1.调度方面：在引入线程的OS中，线程是独立的调度和分派单位，而进程作为资源的拥有单位(相当于把未引入线程的传统OS中的进程的两个属性分开了)。**由于线程不拥有资源，因此可以显著的提高并发度以及减少切换开销**。   2.并发性：引入了线程的OS中，进程间可以并发，而且一个进程内部的多个线程之间也是可以并发的，这就使OS具有更好的并发性，有效的提高了系统资源利用率和吞吐量。   3.拥有资源：无论OS是否支持线程，进程都是基本的资源拥有单位，线程只拥有很少的基本的资源，但是线程可以访问所隶属的进程的资源（进程的代码段，数据段和所拥有的系统资源如fd）   4.系统开销：创建或者撤销进程的时候，系统要为之**创建或回收PCB，系统资源**等，切换时也需要保存和恢复CPU环境。**而线程的切换只需要保存和恢复少量的寄存器，不涉及存储器管理方面的工作，所以开销较小**。此外，统一进程中的多个线程由于共享地址空间，所以通信同步等都比较方便。   协程：在java中没什么应用，了解即可，协程是一种用户态的**轻量级线程（线程的线程）**，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的**切换非常快**。

6. 进程通信（高级方式）：   1.共享存储：在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用**同步互斥工具（如 P操作、V操作）**，对共享空间的写/读进行控制。共享存储又分为两种：低级方式的共享是**基于数据结构的共享**；高级方式则是**基于存储区的共享**。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。需要注意的是，用户进程空间一般都是独立的，要想让两个用户进程共享空间必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。  2.消息传递：进程通过系统提供的发送消息和接收消息**两个原语**进行数据交换。1) 直接通信方式：发送进程直接把消息发送给接收进程，并将**它挂在接收进程的消息缓冲队列上**，接收进程从消息缓冲队列中取得消息。2) 间接通信方式：发送进程把消息**发送到某个中间实体中**，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。   3.管道通信：所谓“管道”，是指用于**连接**一个读进程和一个写进程以实现它们之间通信的一个**共享文件**，又名**pipe文件**。向管道（共享文件）提供输入的发送进程（即写进程），以**字符流形式**将大量的数据送入（写）管道；而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据。为了协调双方的通信，管道机制必须提供以下三方面的**协调能力**：互斥、同步和确定对方的存在。

7. 进程通信方式：1.匿名管道（一个内核缓冲区，单工，只能用于父子或兄弟进程） 2.有名管道（只要由路径就可以访问，存放在内存中） 3.信号（一个进程发送给另一个进程的消息） 4.消息队列（放在内核中的消息链表） 5.共享内存 6.信号量（PV操作，获取到信号量才能执行） 7.套接字

8. 进程调度的策略：1.先来先服务（FCFS）  2.最短作业优先调度算法（SJF）：作业所需的运行时间越短，先运行，但是难以知道作业的运行时间 3.优先级调度算法（抢占/非抢占）：优先级高的先运行，但是会导致低优先级的会无限阻塞（解决方法：老化） 4.时间片轮转调度算法：每一个进程运行固定的时间片 5.多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。 6. 多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用**过多CPU时间**，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生

9. 虚拟地址：虚拟内存是计算机系统内存管理的一种技术。它使得应用程序**认为它拥有连续可用的内存**（一个连续完整的地址空间），而实际上，它通常是被**分隔成多个物理内存碎片**，还有部分暂时**存储在外部磁盘存储器上**，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得**更容易**，对真正的物理内存（例如RAM）的使用也**更有效率**。如果这个空间是虚拟的，我们就叫做虚拟地址空间；如果这个空间是真实存在的，我们就叫做物理地址空间。虚拟地址空间是可以**任意的大的**，因为是虚拟的。而物理地址空间是真实存在的，所以**是有限**的。

10. （https://www.zhihu.com/question/50796850）没有分段与分页时出现的问题：1.地址空间**不隔离**（程序A可能因为地址打错了而访问程序B的地址） 2.程序运行时地址**不确定**（第一次使用时地址可能为0x00000010，第二次使用时地址变了）  3.内存使用**效率低**（进程A需要100M内存，而内存只剩余99M，导致进程A不能运行）  分段（解决问题1，2）：把虚拟地址空间**映射**到了连续的物理地址空间，并且你写的程序操作的是虚拟地址  分页（解决问题1，2，3）：分页这个技术仍然是一种虚拟地址空间到物理地址空间映射的机制。但是，**粒度更加的小了**。单位不是整个程序，而是某个“页”，一段虚拟地址空间组成的某一页映射到一段物理地址空间组成的某一页。

11. 页面调度算法：1.最佳淘汰算法（OPT）：该算法每次都淘汰以后永不使用的，或者过最长的时间后才会被访问的页面。显然，采用这种算法会保证最低的缺页率，但它是无法实现的，因为它必须知道页面“将来”的访问情况。不过，该算法仍有一定意义，可作为衡量其他算法优劣的一个标准。  2.先进先出淘汰算法（FIFO）：总是淘汰最先进入内存的页面。它实现简单，只需把进程中已调入内存的页面，按先后次序链成一个队列，并设置一个所谓的替换指针，使它总是指向内存中最老的页面。  3.最近最久未使用算法（LRU）：根据页面调入内存后的使用情况，选择内存中最久未使用的页面被置换。

12. 寻址空间：CPU的数据总线位宽（即我们常说的32/64位CPU）：CPU一次能处理的二进制位数，如32位CPU一次能处理4字节的指令。CPU的地址总线位宽：CPU的寻址能力，CPU能使用的最大内存空间就由地址总线位宽决定。总而言之，地址总线是用来定位的，数据总线是用来传输的。而操作系统的位数，操作的是逻辑地址，如32位操作系统，最大只能操作4GB的空间，与CPU的位数无关。

13. 银行家算法（试探是否分配，判断安全）：（https://blog.csdn.net/qq_33414271/article/details/80245715）当一个进程申请使用资源的时候，银行家算法通过先试探分配给该进程资源，然后通过安全性算法判断**分配后的系统是否处于安全状态**，若不安全则试探分配作废，让该进程继续等待。那么此时会有一个问题，如何判断系统是否处于安全状态？假设进程P1申请资源，银行家算法先**试探**的分配给它（当然先要看看当前资源池中的资源数量够不够），若申请的资源数量小于等于Available（如果大于，则直接返回不安全），然后接着判断分配给P1后剩余的资源（剩余的资源为p1使用完成释放后的总的资源），能不能使进程队列的某个进程执行完毕，若没有进程可执行完毕，则系统处于不安全状态，若有进程可执行完毕，则此进程释放资源，并标记为可完成，继续试探下一个进程，**若所有进程都可执行完毕，则系统处于安全状态**，并根据可完成进程的分配顺序生成安全序列。（如{P0，P3，P2，P1}表示将申请后的剩余资源Work先分配给P0–>回收（Available+已分配给P0的A0=Available）–>分配给P3–>回收（Available+A3=Available）–>分配给P2–>······满足所有进程）。Allocation：已分配的资源   Need：还需要的资源   Available：当前可获得的资源

14. 磁盘管理（https://blog.csdn.net/yongchaocsdn/article/details/78533187）：

    > 1.磁盘基本认识：磁头固定，磁盘高速旋转来读取数据。磁盘的一个同心圆称为一个磁道，每个磁道与磁头一样宽, 一个盘面有上千个磁道。磁道又划分为几百个扇区（按照固定圆心角划分，所以最外层的扇区长度更长，扇区是磁盘可寻址的最小存储单位），每个扇区固定存储大小（通常为512B), 一个扇区称为一个盘块。多个盘片垂直堆叠，组成磁盘组，每个盘面对应一个 磁头，所有磁头固定在一起，与磁盘中心的距离相同且一起移动。所有盘片上相对位置相同 的磁道组成柱面，磁盘地址 用“柱面号 • 盘面号 • 扇区号（或块号）”表示。
    >
    > ![image-20200821220356710](D:\源码\笔记\图片\image-20200821220356710.png)
    >
    > 2.磁盘调度算法：一次磁盘读写操作的时间由寻找（寻道）时间（定位到磁道的时间）、延迟时间（定位到扇区的时间）和传输时间决定。1.先来先服务  2.最短寻道时间优先（当前磁头最近的磁道，会产生饥饿现象） 3.SCAN（扫描/电梯）算法，总是从最里面一端到最外面一端循环  4.循环扫描（C-SCAN）在扫描算法的基础上规定回返时不提供服务。（默认两个扫描算法都是LOOK调度，即并不到最里面和最外面，而是到最里面和最外面的请求）
    >
    > ![image-20200821223018117](D:\源码\笔记\图片\image-20200821223018117.png)
    >
    > 3.磁盘初始化，引导块：1.磁盘初始化：在磁盘能存储数据之前，它必须**分成扇区**以便磁盘控制器能进行读和写操作，这个过程称为低级格式化（物理分区）。低级格式化为磁盘的每个扇区釆用特别的数据结构。每个扇区的数据结构通常由**头、数据区域（通常为512B大小）和尾部**组成。头部和尾部包含了一些磁盘控制器所使用的信息。为了使用磁盘存储文件，操作系统还需要将自己的数据结构记录在磁盘上：第一步将磁盘分为由**一个或多个柱面组成的分区**（即我们熟悉的C盘、D盘等形式的分区）；第二步对物理分区进行**逻辑格式化（创建文件系统)**，操作系统将初始的文件系统数据结构存储到磁盘上，这些数据结构包括空闲和已分配的空间以及一个初始为空的目录。   2.引导块：计算机启动时需要运行一个初始化程序（自举程序），它初始化CPU、寄存器、设备控制器和内存等，接着启动操作系统。自举程序通常保存在ROM（只读内存，通常放bios与os引导程序）中，为了避免改变自举代码需要改变ROM硬件的问题，故只在ROM中保留很小的自举装入程序，将完整功能的自举程序保存在磁盘的启动块上，启动块位于磁盘的固定位。拥有启动分区的磁盘称为启动磁盘或者系统磁盘。 

15. 僵尸进程(https://blog.csdn.net/LEON1741/article/details/78142269)：1. 产生原因：使用**ps命令**查看进程时状态为defunt，这就是僵尸进程。每个进程在进程表里都有一个名为**进入点**（entry）数据结构，核心程序执行该进程时使用到的一切信息都存储在进入点，当用ps命令察看系统中的进程信息时，看到的就是进程表中的相关数据。当**子进程结束**的时候（比如调用exit命令结束），其实他并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构，此时原来进程表中的数据会被该进程的**退出码**（exit code）、**执行时所用的CPU时间等数据**所取代，这些数据会一直保留到系统**将它传递给它的父进程为止**，由此可见，defunct进程的出现时间是在子进程终止后，但是父进程尚未读取这些数据之前。此时，该僵尸子进程已经放弃了几乎所有的内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态信息供其他进程收集。如果他的父进程没有安装SIGCHLD（sigchld）信号处理函数调用wait 或 waitpid() 等待子进程结束，也没有显式忽略该信号，那么它就一直保持僵尸状态，如果这时候父进程结束了，那么init进程会自动接手这个子进程，为他收尸，他还是能被清除掉的。但是如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是系统中为什么有时候会有很多的僵尸进程。   2.处理：defunct状态下的僵尸进程是不能直接使用kill -9命令杀掉的，否则就不叫僵尸进程了。a.重启计算机 b.找到父进程并杀死父进程（找到父进程的命令：ps -ef | grep defunct_process_pid） 3.如何防止：a. 在父进程创建子进程之前，就向系统申明自己并不会对这个子进程的exit动作进行任何关注行为，这样的话，子进程一旦退出后，系统就不会去等待父进程的操作，而是直接将该子进程的资源回收掉，也就不会出现僵尸进程了。具体的办法就是，在父进程的初始化函数中，调用这个函数：signal(SIGCHLD,SIG_IGN)    b.在创建完子进程后，用waitpid等待子进程返回，也能达到上述效果  c. 在父进程创建子进程的时候，连续调用两次fork()，而且使紧跟的子进程直接退出，使其孙子进程成为孤儿进程，从而init进程将代替父进程来接手，负责清除这个孤儿进程。于是，父进程就无需进行任何的清理行为，系统会自动处理

16. 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。由于孤儿进程会被init进程给收养，所以孤儿进程不会对系统造成危害。

17. PCB（[https://mengchaobbbigrui.github.io/2019/04/20/linux%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/](https://mengchaobbbigrui.github.io/2019/04/20/linux进程详解/)）：在linux中task_struct结构体即是PCB，PCB是进程的唯一标识，PCB由链表实现（为了动态插入和删除）。进程创建时，为该进程生成一个PCB；进程终止时，回收PCB。PCB包含信息：1、进程状态（state）；2、进程标识信息（uid、gid）；3、定时器（time）；4、用户可见寄存器、控制状态寄存器、栈指针等（tss）。每个进程都有一个非负的唯一进程ID（PID）。虽然是唯一的，但是PID可以重用，当一个进程终止后，其他进程就可以使用它的PID了。PID为0的进程为调度进程，该进程是内核的一部分，也称为系统进程；PID为1的进程为init进程，它是一个普通的用户进程，但是以超级用户特权运行；PID为2的进程是页守护进程，负责支持虚拟存储系统的分页操作。

18. select与epoll的区别（https://www.cnblogs.com/aspirant/p/9166944.html）：

19. sdf

20. sdf

21. sdf

































