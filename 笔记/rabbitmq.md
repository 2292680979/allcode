1. 消息队列的好处：通过异步处理提高系统性能（请求放在消息队列中就可以立刻返回响应，而不用等到所有的处理完毕），削峰/限流（设置一个限流数值，把峰值的请求存放在消息队列，峰谷再处理），降低系统耦合（生产者与消费者不直接交互，以后再增加消费者时不用修改生产者代码）。坏处：增加系统复杂性（还要考虑mq的处理），系统可用性降低（mq挂掉），一致性问题（消费者可能实际没有消费）
2. AMQP协议：一个网络协议，支持符合要求的客户端应用（application，即消费者与生产者）和消息中间件代理（messaging middleware broker）之间进行通信。
3. AMQP工作过程：消息（message）被发布者（publisher）发送给交换机（exchange），交换机常常被比喻成邮局或者邮箱。然后交换机将收到的消息根据路由规则分发给绑定的队列（queue）。最后AMQP代理（即消息中间件）会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。
4. 消息确认：从安全角度考虑，网络是不可靠的，接收消息的应用也有可能在处理消息的时候失败。基于此原因，AMQP模块包含了一个消息确认（message acknowledgements）的概念。当一个消息从队列中投递给消费者后（consumer），消费者会通知一下消息代理（broker），这个可以是自动的也可以由处理消息的应用的开发者执行。当“消息确认”被启用的时候，消息代理不会完全将消息从队列中删除，直到它收到来自消费者的确认回执（acknowledgement）。如果一个消费者在尚未发送确认回执的情况下挂掉了，那AMQP代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。在某些情况下，例如当一个消息无法被成功路由时，消息或许会被返回给发布者并被丢弃。或者，如果消息代理执行了延期操作，消息会被放入一个所谓的死信队列中。此时，消息发布者可以选择某些参数来处理这些特殊情况。
5. 拒绝消息：当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于“拒绝消息（Rejecting Messages）”的原因处理失败了（或者未能在此时完成）。当拒绝某条消息时，应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生
6. 消息属性：发布者（publisher）发布消息时可以给消息指定各种消息属性（message meta-data）。有些属性有可能会被消息代理（brokers）使用，然而其他的属性则是完全不透明的，它们只能被接收消息的应用所使用。消息属性：Content type，Content encoding，Routing key，Message publishing timestamp，Delivery mode (persistent or not)等等，AMQP的消息除属性外，也含有一个有效载荷 - Payload（消息实际携带的数据），它被AMQP代理当作不透明的字节数组来对待。消息代理不会检查或者修改有效载荷。消息可以只包含属性而不携带有效载荷。它通常会使用类似JSON这种序列化的格式数据。
7. 交换机使用的交换算法：
   1. Direct exchange（直连交换机）：将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key），当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。
   2. Fanout exchange（扇型交换机）：将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。
   3. Topic exchange（主题交换机）：对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。
   4. Headers exchange（头交换机，不推荐）：头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。如在rabbitmq中，消息header数据中有一个特殊值x-match，他有两个值：all：默认值，消息的header中键值对与绑定全部匹配  any：任一匹配。
   5. Default exchange（默认交换机）：没有名字的直连交换机，每个新建队列都会自动绑定到此交换机上，路由键即为队列名称，所以可以实现直接发送到某个队列。
8. 交换机属性与状态：交换机属性：name，durability（消息代理重启后，交换机是否还存在），auto-delete（当所有与之绑定的消息队列都完成了对此交换机的使用后，删掉它），arguments（依赖代理本身）    交换机属性：name，durability（消息代理重启后，交换机是否还存在），auto-delete（当所有与之绑定的消息队列都完成了对此交换机的使用后，删掉它），arguments（依赖代理本身）
9. 队列属性与使用：队列属性：name，durable（代理重启后，队列依旧存在），exclusive（只被一个连接使用，连接关闭后队列被删除），auto-delete（最后一个消费者退订后删除队列），arguments     使用： 队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为406的通道级异常就会被抛出。持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。
10. rabbitmq在springboot中使用：首先需要安装erlang，然后安装rabbitmq-broker，安装完成后不用任何配置就能开始写代码了（本地运行时，默认值都是正确的）。  开始在configuration下装配bean：交换机（指定名字），队列（指定名字），绑定（即BindingBuilder类，队列与交换机绑定并指定routingkey），listener（listener类需要注入接受消息后的处理对象），container（设置listener，ConnectionFactory，队列名字，这一步相当于把队列与回调方法绑定，其实并不用写container与listener，只需要在回调方法的类上面注解@Component与@RabbitListener(queue="")并且在回调方法上注解@RabbitHandler即可），然后即可开始监听此队列的消息了，有匹配routingkey的消息发送过来便会调用listener中的回调方法。 使用rabbitTemplate发送消息，注明交换机名称，消息的routingkey，以及消息内容。  要使用多个queue只需要定义多个不同名字的队列@Bean与多个绑定@Bean即可。（注意，队列的名字只是操作时识别此queue的，消息匹配匹配的时绑定时的routingkey）
11. sdf