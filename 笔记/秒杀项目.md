1. https://www.nowcoder.com/discuss/455012?type=post&order=time&pos=&page=1&channel=666&source_id=search_post

2. 环境变量问题：在项目下的terminal运用mvn命令使用的是3.6.0，而我在外面配置的确是3.6.3，为什么在idea与外面使用的mvn是不一样的呢？首先，我改变了setting里面的maven配置，但是还是3.6.0，最后发现是idea的setting里面的terminal下面的环境变量设置为了3.6.0的maven，设置回来重启idea就ok了。

3. maven项目声明周期：

   - clean：清理，在进行真正的构建之前进行一些清理工作，移除所有上一次构建生成的文件。执行该命令会**删除项目路径下的target文件**，但是不会删除本地的maven仓库已经生成的jar文件。

   - validate：验证工程是否正确，所需的信息是否完整。

   - compile：编译源码，只编译选定的目标，不管之前是否已经编译过，会在你的项目路径下生成一个target目录，在该目录中包含一个classes文件夹
   - test：单元测试
   - package：package命令完成了项目编译、单元测试、打包功能，但没有把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库。**package，install，deploy使用一般搭配clean，如mvn clean package**
   - verify：检查package是否有效，符合标准
   - install：install命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库，但没有布署到远程maven私服仓库
   - deploy：deploy命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库
   - compile与build区别：build是对整个工程进行彻底的重新编译，而不管是否已经编译过。Build过程往往会生成发布包，这个具体要看对IDE的配置了，Build在实际中应用很少，因为开发时候基本上不用，发布生产时候一般都用ANT等工具来发布。Build因为要全部编译，还要执行打包等额外工作，因此时间较长。compile只编译选定的目标，不管之前是否已经编译过。

4. 在项目实体类中，属性为什么要用包装类？在数据库读取或者接受前端的数据时，如果属性为null，显然，null是不能赋值给基本类型的，而用包装类就不会报错了，可以规避这个问题。

5. 原始秒杀项目：商品数量减1应该在数据库层面做，而不是java层面，要不然并发时会有bug

6. 项目中，service所有方法一般都要加上@Transactional注解，防止出现异常改变了数据库。

7. 记录日志的组件：log4j与logback，logback相比log4j更快，是它的升级版。logback由三个模块组成：logback-core/classic/access。slf4j是一系列的日志接口，slf4j是作为一个日志的抽象行为存在的，但是并没有提供真正的实现，Logback，Log4j，common-logging等框架都实现了这些接口。springboot使用log4j只需要在pom文件中添加依赖即可。因为springboot默认集成了logback，我们只需要在properties文件中配置属性就行了：https://www.jianshu.com/p/1fa12b92d5c4

8. 商品价格用BigDecimal而不是double/float，因为double等会丢失精度。

9. 用mybatis时，在mapper接口中写插入/更新语句时，只需要在方法中传入实体类，然后在sql语句中直接用此实体类的属性即可（sql语句写法：UPDATE/DELETE/WHERE等关键字大写，变量/表等小写）

   

